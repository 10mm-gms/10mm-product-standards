{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"decisions/0001-record-architecture-decisions.html","title":"1. Record Architecture Decisions","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0001-record-architecture-decisions.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0001-record-architecture-decisions.html#context","title":"Context","text":"<p>We need a way to record architectural decisions, the context of those decisions, and the consequences of those decisions. This needs to be consistent across all products to ensuring that historical context is preserved and new team members (and AI agents) can understand the \"why\" behind the system design.</p>"},{"location":"decisions/0001-record-architecture-decisions.html#decision","title":"Decision","text":"<p>We will use Architecture Decision Records (ADRs), as described by Michael Nygard.</p> <ul> <li>We will store these decisions in the repository under <code>docs/decisions</code>.</li> <li>We will use a lightweight Markdown format.</li> <li>The naming convention will be <code>NNNN-title-in-kebab-case.md</code> (e.g., <code>0001-record-architecture-decisions.md</code>).</li> <li>ADRs are immutable once accepted (except for Status updates).</li> </ul>"},{"location":"decisions/0001-record-architecture-decisions.html#consequences","title":"Consequences","text":"<ul> <li>Positive: Clear history of decisions.</li> <li>Positive: AI agents can easily ingest this folder to understand constraints.</li> <li>Negative: Slight overhead in writing them down, but pays off in clarity.</li> </ul>"},{"location":"decisions/0002-use-tailwind-css.html","title":"2. Use Tailwind CSS for Styling","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0002-use-tailwind-css.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0002-use-tailwind-css.html#context","title":"Context","text":"<p>We need a consistent way to style web applications across multiple products. The team desires high-quality, \"premium\" design but lacks dedicated design resources. Previous approaches involving adopting pre-made templates (Bootstrap) often result in \"messy adapted code\" when customization is required. We need a solution that allows for rapid development, consistency, and easy manipulation by AI agents.</p>"},{"location":"decisions/0002-use-tailwind-css.html#decision","title":"Decision","text":"<p>We will use Tailwind CSS as our primary styling framework.</p> <ul> <li>Utility-First: We will style components using utility classes directly in the markup.</li> <li>Headless Components: For complex interactive components (modals, dropdowns), we will prefer \"headless\" libraries (like Radix UI or Headless UI) styled with Tailwind, or copy-paste collections like shadcn/ui.</li> <li>No Global CSS: We will avoid writing custom CSS files except for global resets or specific animations not covered by the config.</li> </ul>"},{"location":"decisions/0002-use-tailwind-css.html#consequences","title":"Consequences","text":"<ul> <li>Positive: High consistency across projects via shared <code>tailwind.config.js</code>.</li> <li>Positive: AI Agents are very proficient at generating valid Tailwind classes.</li> <li>Positive: Eliminates the \"messy CSS\" problem of appended stylesheets and overriding rules.</li> <li>Negative: HTML markup becomes verbose (many classes per element).</li> <li>Mitigation: We will use component-based architectures (React/Vue/WebComponents) to encapsulate this verbosity.</li> </ul>"},{"location":"decisions/0003-use-shadcn-ui.html","title":"3. Use shadcn/ui for Component Library","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0003-use-shadcn-ui.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0003-use-shadcn-ui.html#context","title":"Context","text":"<p>We have decided to use Tailwind CSS (ADR-0002). Building accessible, high-quality components from scratch is time-consuming. We need a solution that accelerates development while maintaining the \"premium\" feel and avoiding the generic look of pre-packaged libraries (like Bootstrap or Material UI). We want to retain full control over the component code to allow for specific customizations.</p>"},{"location":"decisions/0003-use-shadcn-ui.html#decision","title":"Decision","text":"<p>We will use shadcn/ui as our primary component library.</p> <ul> <li>Implementation: Components are added to the codebase (no npm dependency for the library itself).</li> <li>Primitives: Built on top of Radix UI for accessibility (headless primitives).</li> <li>Styling: Styled with Tailwind CSS.</li> <li>Icons: Lucide React (standard pairing with shadcn).</li> </ul>"},{"location":"decisions/0003-use-shadcn-ui.html#consequences","title":"Consequences","text":"<ul> <li>Positive: \"Best of both worlds\" - speed of a library, flexibility of custom code.</li> <li>Positive: Excellent accessibility out of the box.</li> <li>Positive: Consistent design language (Typography, Spacing, Colors).</li> <li>Negative: Updates are manual. If shadcn/ui updates a component we've heavily modified, we have to resolve conflicts manually.</li> </ul>"},{"location":"decisions/0004-use-python-fastapi.html","title":"4. Use Python (FastAPI) for Backend Services","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0004-use-python-fastapi.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0004-use-python-fastapi.html#context","title":"Context","text":"<p>We are building a suite of products that may require future AI/Data integration. The primary developer has significant experience in Perl and Java, making Python a natural bridge (scripting flexibility + strong typing support). We need a framework that adheres to our API-First standard (OpenAPI generation) and is highly performant.</p>"},{"location":"decisions/0004-use-python-fastapi.html#decision","title":"Decision","text":"<p>We will use Python with the FastAPI framework for backend services.</p> <ul> <li>Language: Python 3.12+</li> <li>Framework: FastAPI</li> <li>Type Safety: We enforce strict type hints (mypy/pyright) to mimic strong typing.</li> <li>ORM: SQLModel or SQLAlchemy (Async).</li> <li>Package Manager: <code>uv</code> (modern, extremely fast replacement for pip/poetry).</li> </ul>"},{"location":"decisions/0004-use-python-fastapi.html#consequences","title":"Consequences","text":"<ul> <li>Positive: Native ecosystem for AI/LLM libraries.</li> <li>Positive: Automatic OpenAPI (Swagger) documentation generation.</li> <li>Positive: High developer velocity.</li> <li>Negative: Lower raw execution speed than Go/Rust (usually negligible for I/O bound web apps).</li> <li>Mitigation: Use <code>uvicorn</code> with <code>gunicorn</code> for production concurrency.</li> </ul>"},{"location":"decisions/0005-use-react-native-expo.html","title":"5. Use React Native &amp; Expo for Mobile Applications","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0005-use-react-native-expo.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0005-use-react-native-expo.html#context","title":"Context","text":"<p>We anticipate building mobile applications for several products, including requirements for native hardware access (Camera for condition photos). We have already selected React for the web frontend (ADR-0003 Context), creating a skill pool in JavaScript/TypeScript/React. The team needs to support both iOS and Android without maintaining two distinct native codebases (Swift/Kotlin).</p>"},{"location":"decisions/0005-use-react-native-expo.html#decision","title":"Decision","text":"<p>We will use React Native with the Expo framework for all mobile applications.</p> <ul> <li>Framework: Expo. We will use the \"Managed Workflow\" where possible for ease of builds and updates.</li> <li>Language: TypeScript (Shared with Web).</li> <li>Styling: NativeWind. Although React Native doesn't use CSS, NativeWind allows us to use the exact same Tailwind classes we use on the web.</li> <li>Navigation: Expo Router (File-based routing, similar to Next.js on the web).</li> </ul>"},{"location":"decisions/0005-use-react-native-expo.html#consequences","title":"Consequences","text":"<ul> <li>Positive (Android/iOS Parity): React Native renders to true native UI widgets on both platforms. It is not a \"webview\" wrapper; it feels native because it is native.</li> <li>Positive (Code Reuse): We can share extensive logic (state, API clients, validation) between the Web and Mobile repos (or arguably a monorepo).</li> <li>Positive (Hardware): Expo provides robust SDKs for Camera, Location, Notifications, etc., that work identically across both platforms.</li> <li>Negative: Some extremely high-performance animations (60fps gestures) require more care than in pure native code, but this is rarely a blocker for business apps like \"Vehicle Check.\"</li> </ul>"},{"location":"decisions/0006-use-unified-tech-stack.html","title":"6. Use Unified Tech Stack","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0006-use-unified-tech-stack.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0006-use-unified-tech-stack.html#context","title":"Context","text":"<p>We are building a suite of products. To allow developers (and AI agents) to move seamlessly between projects, and to reduce the cognitive load of decision-making for every new service, we need a \"default\" technology stack. Fragmentation in languages and frameworks leads to: - Slower onboarding. - Duplicated tooling (linting, CI/CD). - Difficulty in sharing code/types between services. - Reduced effectiveness of AI coding assistants (which benefit from consistent patterns).</p>"},{"location":"decisions/0006-use-unified-tech-stack.html#decision","title":"Decision","text":"<p>We will adopt a Unified Tech Stack as the default for all new applications in this product suite. This stack consists of the specific technologies chosen in separate ADRs:</p> <ul> <li>Styling: Tailwind CSS (ADR-0002)</li> <li>UI Components: shadcn/ui (ADR-0003)</li> <li>Backend API: Python FastAPI (ADR-0004)</li> <li>Client Framework: React Native w/ Expo (ADR-0005)</li> </ul> <p>Exceptions to this default must be justified by a specific business or technical requirement and documented in a new ADR.</p>"},{"location":"decisions/0006-use-unified-tech-stack.html#consequences","title":"Consequences","text":"<ul> <li>Positive: \"Batteries included\" start for new projects.</li> <li>Positive: Shared knowledge base and patterns.</li> <li>Negative: Less flexibility for developers who prefer other tools (e.g., pure React, Go).</li> </ul>"},{"location":"decisions/0007-modular-monolith-architecture.html","title":"7. Use Modular Monolith Architecture","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0007-modular-monolith-architecture.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0007-modular-monolith-architecture.html#context","title":"Context","text":"<p>We are building a new product suite. We have conflicting requirements: 1.  MVP Speed: We need to ship and iterate fast to prove the concept. 2.  Scalability: If successful, the system may need to handle high load and be split into teams.</p> <p>Typical approaches have downsides: *   Microservices first: Accidental complexity, distributed systems fallacies (network latency, consistency), high infra overhead for an unproven product. *   Classic Monolith: \"Big ball of mud,\" tight coupling making future splitting impossible.</p>"},{"location":"decisions/0007-modular-monolith-architecture.html#decision","title":"Decision","text":"<p>We will build a Modular Monolith.</p> <ul> <li>Single Deployment Unit: All \"services\" (Auth, Core, Payments) run within a single FastAPI process (or cluster of identical processes).</li> <li>Strict Module Boundaries: Code is organized into modules (e.g., <code>src/auth</code>, <code>src/billing</code>) that enforce interface boundaries.<ul> <li>Cross-module communication occurs via simple function calls (in-process).</li> <li>No direct database access across modules (e.g., Billing cannot query Auth tables directly; it must ask the Auth module).</li> </ul> </li> <li>Future-Ready: Since modules are decoupled, properly bounded contexts are established. Moving <code>src/billing</code> to a separate microservice later is a mechanical refactor (replace function call with gRPC/HTTP client), not a rewrite.</li> </ul>"},{"location":"decisions/0007-modular-monolith-architecture.html#consequences","title":"Consequences","text":"<ul> <li>Positive: Zero network latency between components.</li> <li>Positive: Simple \"one container\" deployment.</li> <li>Positive: Codebase is structured for scale from Day 1 without the infra tax.</li> <li>Negative: Must discipline developers to avoid coupling modules (using linting tools like <code>import-linter</code> is recommended).</li> </ul>"},{"location":"decisions/0008-use-postgresql-for-primary-db.html","title":"8. Use PostgreSQL for Primary Storage &amp; AI","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0008-use-postgresql-for-primary-db.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0008-use-postgresql-for-primary-db.html#context","title":"Context","text":"<p>We need a database that effectively handles: 1.  Relational data (users, orders, relational integrity). 2.  JSON documents (flexible schemas for rapid prototyping). 3.  Vector Embeddings: For future LLM/AI features (semantic search, RAG).</p> <p>Managing multiple specialty databases (e.g., Postgres + Mongo + Pinecone) introduces distributed transaction headaches and high operational complexity.</p>"},{"location":"decisions/0008-use-postgresql-for-primary-db.html#decision","title":"Decision","text":"<p>We will use PostgreSQL as our primary persistence layer.</p> <ul> <li>Relational: Standard normalized tables for core data.</li> <li>Vector Search: We will use the <code>pgvector</code> extension for storing and querying embeddings.</li> <li>Search: We will use <code>pg_trgm</code> for fuzzy text search until dedicated search infrastructure (Elasticsearch) is strictly required.</li> </ul>"},{"location":"decisions/0008-use-postgresql-for-primary-db.html#consequences","title":"Consequences","text":"<ul> <li>Positive: ACID compliance for all data transactions.</li> <li>Positive: \"One DB to rule them all\" simplifies backups, local dev, and testing.</li> <li>Positive: Seamless joining of relational data with vector similarity results (e.g., \"Find similar documents created by User X\").</li> <li>Negative: Postgres vector search may be slower than specialized vector DBs at massive scale (100M+ vectors), but sufficient for &lt;10M scale.</li> </ul>"},{"location":"decisions/0009-enforce-stateless-services.html","title":"9. Enforce Stateless Services","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0009-enforce-stateless-services.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0009-enforce-stateless-services.html#context","title":"Context","text":"<p>We require High Availability (HA). This means no single point of failure and the ability to handle traffic spikes by adding more servers. If a server holds state (e.g., \"User 123 is logged in on Server A\" via in-memory sessions), we cannot simply route that user's next request to Server B without complex sticky sessions.</p>"},{"location":"decisions/0009-enforce-stateless-services.html#decision","title":"Decision","text":"<p>All application services must be Stateless.</p> <ul> <li>No Local State: No data required for a request shall persist in the application process memory or local filesystem after the request completes.</li> <li>External State: All state must be stored in backing services:<ul> <li>Database: PostgreSQL for persistent data.</li> <li>Cache/Session: Redis for ephemeral data (session stores, rate limits).</li> <li>Object Storage: S3/GCS for file uploads.</li> </ul> </li> </ul>"},{"location":"decisions/0009-enforce-stateless-services.html#consequences","title":"Consequences","text":"<ul> <li>Positive: Trivial Horizontal Scaling. We can spin up 1 or 100 instances behind a Load Balancer and round-robin traffic.</li> <li>Positive: Zero-downtime deployments (rolling updates) are easy.</li> <li>Negative: Requires external infrastructure (Redis) even for simple apps.</li> </ul>"},{"location":"decisions/0010-comprehensive-testing-strategy.html","title":"10. Comprehensive Testing Strategy","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0010-comprehensive-testing-strategy.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0010-comprehensive-testing-strategy.html#context","title":"Context","text":"<p>We need a consistent testing strategy to ensure reliability across our unified tech stack (FastAPI, React Native/Expo, shadcn/ui). Without a standard, some teams might rely often on manual QA or slow E2E tests, while others might over-mock unit tests.</p>"},{"location":"decisions/0010-comprehensive-testing-strategy.html#decision","title":"Decision","text":""},{"location":"decisions/0010-comprehensive-testing-strategy.html#methodology-tdd-is-encouraged-not-required","title":"Methodology: TDD is Encouraged, Not Required","text":"<p>We view Test-Driven Development (TDD) as a valuable tool for designing interfaces and handling complex logic, but we do not overly enforce it for boilerplate code.</p> <ul> <li>Complex Logic: Strongly Recommended. (e.g., pricing algorithms, complex state transitions). Write the test first to clarify the requirements.</li> <li>Boilerplate / CRUD: Optional. (e.g., simple database models, pass-through API endpoints). It is acceptable to write tests after the implementation, provided they are written in the same PR.</li> </ul> <p>We value confidence and coverage over the chronological order of test writing.</p> <p>We will follow the Testing Pyramid:</p>"},{"location":"decisions/0010-comprehensive-testing-strategy.html#1-unit-tests-70","title":"1. Unit Tests (70%)","text":"<ul> <li>Scope: Individual functions, classes, and components. Fast and isolated.</li> <li>Backend: <code>pytest</code>.</li> <li>Frontend: <code>vitest</code> + <code>react-testing-library</code>.</li> </ul>"},{"location":"decisions/0010-comprehensive-testing-strategy.html#2-integration-tests-20","title":"2. Integration Tests (20%)","text":"<ul> <li>Scope: Interactions between immediate dependencies (API interactions with DB, Component interactions with Hooks).</li> <li>Backend: <code>pytest</code> + <code>testcontainers</code> (spin up real Postgres/Redis in Docker).<ul> <li>Note: Avoid mocking databases if possible; use ephemeral containers.</li> </ul> </li> <li>Frontend: Render components that include React Query / API calls (mocking the network layer via MSW or similar).</li> </ul>"},{"location":"decisions/0010-comprehensive-testing-strategy.html#3-end-to-end-e2e-tests-10","title":"3. End-to-End (E2E) Tests (10%)","text":"<ul> <li>Scope: Critical user flows (Login, Checkout) running against a full environment.</li> <li>Tool: Playwright.</li> <li>Philosophy: Test distinct critical paths. Do not test edge cases here (push those down to unit tests).</li> </ul>"},{"location":"decisions/0010-comprehensive-testing-strategy.html#cicd-enforcement","title":"CI/CD Enforcement","text":"<ul> <li>All tests must pass in CI before merging.</li> <li>Coverage metrics are collected but loose (no hard 100% requirement), aiming for meaningful coverage.</li> </ul>"},{"location":"decisions/0010-comprehensive-testing-strategy.html#consequences","title":"Consequences","text":"<ul> <li>Positive: High confidence in releases.</li> <li>Positive: \"Shift Left\" - bugs caught early in unit tests.</li> <li>Negative: Integration tests with <code>testcontainers</code> can be slower than mocks.</li> <li>Negative: Maintaining E2E tests requires dedicated effort to avoid flakiness.</li> </ul>"},{"location":"decisions/0011-observability-strategy.html","title":"11. Observability Strategy","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0011-observability-strategy.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0011-observability-strategy.html#context","title":"Context","text":"<p>We need to monitor our applications in production. Using client libraries to ship logs (e.g., <code>datadog-py</code>, <code>winston-cloudwatch</code>) couples the application code to a specific vendor and increases latency/complexity within the app process.</p>"},{"location":"decisions/0011-observability-strategy.html#decision","title":"Decision","text":"<p>We will follow the 12-Factor App methodology for observability.</p>"},{"location":"decisions/0011-observability-strategy.html#1-logs-streams-not-files","title":"1. Logs (Streams not Files)","text":"<ul> <li>Mechanism: Applications must write purely to <code>stdout</code> (for info) and <code>stderr</code> (for errors).</li> <li>Format: Structured JSON (as defined in Coding Guidelines).</li> <li>Shipping: We rely on the Node Agent pattern.<ul> <li>Explanation: The application writes to <code>stdout</code>. The container runtime (Docker/Containerd) captures this output and writes it to a file on the host machine. A specialized \"Node Agent\" (e.g., Datadog Agent, Fluentd) running on that same host reads these files and ships them to the cloud.</li> <li>Benefit: The app container remains completely isolated and doesn't need to know how or where logs are sent.</li> </ul> </li> <li>Banned: Writing to local log files (e.g., <code>/var/log/app.log</code>) or managing log rotation within the app.</li> </ul>"},{"location":"decisions/0011-observability-strategy.html#2-metrics-pull-not-push","title":"2. Metrics (Pull not Push)","text":"<ul> <li>Mechanism: Applications must expose a <code>/metrics</code> HTTP endpoint.</li> <li>Format: Prometheus text format.</li> <li>Collection: The monitoring agent (Prometheus/Datadog Agent) scrapes this endpoint periodically.</li> <li>Why Pull?: In a \"Push\" model, the app must know where to send metrics (coupling). In a \"Pull\" model, the app just exposes its state, and the infrastructure decides when/how to collect it. This prevents the app from being overwhelmed by reporting duties.</li> </ul>"},{"location":"decisions/0011-observability-strategy.html#3-tracing","title":"3. Tracing","text":"<ul> <li>Standard: OpenTelemetry (OTEL).</li> <li>Mechanism: Auto-instrumentation where possible. Traces are sent to a local OTEL collector agent (sidecar), not directly to the backend over the WAN.</li> <li>Explanation: \"Auto-instrumentation\" means the OTEL agent attaches to the running process (like a debugger) and captures HTTP/DB calls automatically, without the developer writing code to \"start span\" or \"end span\".</li> </ul>"},{"location":"decisions/0011-observability-strategy.html#consequences","title":"Consequences","text":"<ul> <li>Positive: Vendor Neutrality. We can switch from Datadog to CloudWatch by changing the infra agent, without touching app code.</li> <li>Positive: Cloud-Native Compatibility. Platforms like Google Cloud Run and AWS Fargate handle this natively:<ul> <li>They automatically capture <code>stdout</code> logs (no agent needed).</li> <li>They have managed services for Prometheus scraping and OTel ingestion.</li> <li>This means \"Day 1\" deployment requires ZERO infrastructure setup for users on these platforms.</li> </ul> </li> <li>Positive: Performance. App only writes to memory buffer (stdout), not network sockets.</li> <li>Negative: Developers must rely on <code>docker logs</code> or the centralized dashboard, as there are no local log files to <code>tail</code>.</li> </ul>"},{"location":"decisions/0012-app-execution-standards.html","title":"12. App Execution Standards","text":"<p>Date: 2025-12-21</p>"},{"location":"decisions/0012-app-execution-standards.html#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/0012-app-execution-standards.html#context","title":"Context","text":"<p>We need to define how applications are executed in containers. 1.  How do they serve HTTP traffic? (Embedded server vs Reverse Proxy). 2.  How do they perform administrative tasks like Database Migrations?</p>"},{"location":"decisions/0012-app-execution-standards.html#decision","title":"Decision","text":"<p>We will follow the 12-Factor App principles for execution.</p>"},{"location":"decisions/0012-app-execution-standards.html#1-port-binding-self-contained","title":"1. Port Binding (Self-Contained)","text":"<ul> <li>Principle: The app exports itself as a service by binding to a port.</li> <li>Implementation: Use Uvicorn (for FastAPI) explicitly.<ul> <li>Command: <code>uvicorn main:app --host 0.0.0.0 --port $PORT</code></li> <li>Do Not Use: Apache <code>mod_wsgi</code> or Nginx <code>uWSGI</code> wrappers inside the container. If a reverse proxy is needed, it should be a separate layer (Ingress / Load Balancer).</li> </ul> </li> </ul>"},{"location":"decisions/0012-app-execution-standards.html#2-admin-processes-one-off-jobs","title":"2. Admin Processes (One-Off Jobs)","text":"<ul> <li>Principle: Admin tasks (db migrations, REPL shells) are first-class processes.</li> <li>Implementation: Run DB migrations as a Job (Kubernetes Job / Cloud Run Job) before the new code deployment traffic begins.<ul> <li>Do Not: Run migrations as a <code>prestart.sh</code> script inside the main app container.</li> <li>Why?: If scaling to 10 instances, 10 containers would try to migrate the DB simultaneously (race condition).</li> </ul> </li> </ul>"},{"location":"decisions/0012-app-execution-standards.html#consequences","title":"Consequences","text":"<ul> <li>Positive: Dev/Prod Parity. The way you run <code>uvicorn</code> locally is exactly how it runs in Prod.</li> <li>Positive: Safety. Decoupling migrations from startup prevents \"crash loops\" where a bad migration brings down the web server.</li> </ul>"},{"location":"standards/agile_workflow.html","title":"Agile-as-Code Standard","text":"<p>This standard provides a \"middle ground\" between heavy Scrum tools (Jira, Linear) and unmanaged text files. It separates Management (Prioritization) from Definition (Requirements).</p>"},{"location":"standards/agile_workflow.html#1-the-manager-view-boardmd","title":"1. The Manager View: <code>BOARD.md</code>","text":"<p>To avoid learning Markdown syntax for management, we use a single file <code>planning/BOARD.md</code> that acts as your Kanban board. You simply move lines up and down.</p> <p>Structure: *   Backlog: Ideas and future work. *   Ready: Specs are defined, ready for dev. *   In Progress: Active work. *   Done: Completed.</p> <p>Format (Simple List): <pre><code># Board\n\n## In Progress\n- [ ] [STORY-101] Login Page (assigned: @me)\n\n## Ready (Prioritized)\n- [ ] [STORY-102] Forgot Password Flow\n- [ ] [STORY-105] User Profile\n\n## Backlog\n- [ ] [EPIC-A] Admin Dashboard\n- [ ] Something about email notifications (needs spec)\n</code></pre> You treat this file like a drag-and-drop list.</p>"},{"location":"standards/agile_workflow.html#2-the-artifacts-epics-stories","title":"2. The Artifacts: Epics &amp; Stories","text":"<p>Instead of flat folders, we use a hierarchical structure. Every Epic has its own directory.</p> <ul> <li>Epics (<code>planning/epics/[EPIC-ID]/epic.md</code>): High-level goals.</li> <li>Stories (<code>planning/epics/[EPIC-ID]/stories/*.md</code>): Specific, shippable units that live inside the epic folder.</li> </ul>"},{"location":"standards/agile_workflow.html#the-ai-assisted-workflow","title":"The AI-Assisted Workflow","text":"<ol> <li>You add a bullet point to <code>BOARD.md</code>: \"- [ ] [EPIC-10] User Profile\".</li> <li>AI (Me) creates <code>planning/epics/EPIC-10-user-profile/epic.md</code>.</li> <li>We add stories under <code>planning/epics/EPIC-10-user-profile/stories/STORY-11.md</code>.</li> </ol>"},{"location":"standards/agile_workflow.html#3-directory-structure","title":"3. Directory Structure","text":"<pre><code>product_standards/\n\u2514\u2500\u2500 planning/\n    \u251c\u2500\u2500 BOARD.md\n    \u2514\u2500\u2500 epics/\n        \u2514\u2500\u2500 EPIC-10-user-profile/\n            \u251c\u2500\u2500 epic.md\n            \u2514\u2500\u2500 stories/\n                \u251c\u2500\u2500 STORY-11-edit-avatar.md\n                \u2514\u2500\u2500 STORY-12-change-password.md\n</code></pre>"},{"location":"standards/agile_workflow.html#why-this-works","title":"Why this works?","text":"<ol> <li>Prioritization: You just reorder lines in <code>BOARD.md</code>.</li> <li>Context: AI can read all files easily, unlike a closed SaaS tool.</li> <li>Low Friction: You write bullets; AI writes the complex Markdown.</li> </ol>"},{"location":"standards/api_standards.html","title":"API &amp; Code Generation Standards","text":""},{"location":"standards/api_standards.html#philosophy","title":"Philosophy","text":"<p>We prefer contract-first development. Defining contracts explicitly allowing us to generate documentation, clients, and server stubs, ensuring consistency.</p>"},{"location":"standards/api_standards.html#rest-apis","title":"REST APIs","text":"<ul> <li>Standard: OpenAPI 3.1</li> <li>File Location: <code>api/openapi.yaml</code> in the respective service repo.</li> <li>Tools:<ul> <li>Linting: <code>spectral</code></li> <li>Docs: <code>Swagger UI</code> or <code>Redoc</code></li> <li>Code Gen: <code>openapi-generator</code> or <code>orval</code> (for Frontend)</li> </ul> </li> </ul>"},{"location":"standards/api_standards.html#api-namespace-spa-routing","title":"API Namespace &amp; SPA Routing","text":"<p>To prevent routing collisions between backend endpoints and Single Page Application (SPA) client-side routers, all backend API routes must be namespaced under a clear prefix.</p> <ul> <li>Standard Prefix: <code>/api</code> (or <code>/api/v1</code>).</li> <li>Routing Fallback: The backend root (<code>/</code>) and any non-prefixed paths should serve the SPA <code>index.html</code>, allowing the frontend router to handle deep-linked URLs (e.g., <code>/dashboard/items</code>) without premature interference from backend authentication middleware.</li> </ul>"},{"location":"standards/api_standards.html#standard-error-responses","title":"Standard Error Responses","text":"<p>To ensure the Frontend can consistently handle errors, all APIs must follow RFC 7807 (Problem Details for HTTP APIs).</p> <p>JSON Structure: <pre><code>{\n  \"type\": \"https://example.com/probs/out-of-credit\",\n  \"title\": \"You do not have enough credit.\",\n  \"detail\": \"Your current balance is 30, but that costs 50.\",\n  \"instance\": \"/account/12345/msgs/abc\",\n  \"status\": 403\n}\n</code></pre> *   Benefits: Frontend can have a single <code>ErrorHandler</code> component that parses <code>title</code> and <code>detail</code> for any 4xx/5xx error globally.</p>"},{"location":"standards/api_standards.html#secure-redirect-error-reporting","title":"Secure Redirect Error Reporting","text":"<p>For processes using HTTP redirects (like OAuth/OIDC callbacks), never pass user-facing error strings in query parameters. This prevents XSS and reflection vulnerabilities.</p> <ul> <li>Mandatory: Use standardized error codes (e.g., <code>?error=domain_restricted</code>).</li> <li>Implementation: The Frontend must map these codes to predefined, safe local messages.</li> </ul>"},{"location":"standards/api_standards.html#event-driven-architecture","title":"Event-Driven Architecture","text":"<ul> <li>Standard: AsyncAPI</li> <li>Usage: For defining message payloads and topics (Kafka/RabbitMQ).</li> </ul>"},{"location":"standards/api_standards.html#code-generation","title":"Code Generation","text":"<p>When possible, generate boilerplate from these standards to avoid manual drift. *   Do not edit generated files manually. *   Regenerate as part of the build process or commit with a clear provenance.</p>"},{"location":"standards/cicd.html","title":"CI/CD Standard (v0.1)","text":"<p>This document defines our Local-First CI/CD philosophy. We prioritize automation that runs on a developer's machine exactly as it runs in a remote environment.</p>"},{"location":"standards/cicd.html#1-philosophy-local-first","title":"1. Philosophy: Local-First","text":"<p>We avoid platform-specific lock-in (e.g., GitHub Actions, GitLab CI logic). *   Agnosticism: The \"Brain\" of the pipeline must be a set of portable scripts/commands in the repository. *   Parity: Running the pipeline locally must be identical to running it in a CI tool. *   Entry Point: Every project must have a <code>Makefile</code> or <code>Taskfile</code> as the standardized interface for automation.</p>"},{"location":"standards/cicd.html#2-pipeline-stages","title":"2. Pipeline Stages","text":"<p>The pipeline is realized via three standardized commands:</p>"},{"location":"standards/cicd.html#make-fmt-format","title":"<code>make fmt</code> (Format)","text":"<ul> <li>Fixes style issues automatically.</li> <li>Uses <code>ruff format</code> (Python) or <code>prettier --write</code> (frontend).</li> </ul>"},{"location":"standards/cicd.html#make-lint-check","title":"<code>make lint</code> (Check)","text":"<ul> <li>Static analysis and style enforcement.</li> <li>Must pass before committing.</li> </ul>"},{"location":"standards/cicd.html#make-test-verify","title":"<code>make test</code> (Verify)","text":"<ul> <li>Runs unit and integration tests.</li> <li>Uses <code>TestContainers</code> locally or service containers in CI.</li> </ul>"},{"location":"standards/cicd.html#make-build-release","title":"<code>make build</code> (Release)","text":"<ul> <li>Packages the application into an OCI (Docker) image.</li> </ul>"},{"location":"standards/cicd.html#3-build-identification-the-build-id","title":"3. Build Identification (The \"Build ID\")","text":"<p>In a local-first environment, we use the Git Commit Count to provide a sequential integer build number. This ensures traceability without requiring a persistent file state like a <code>BUILD</code> file.</p>"},{"location":"standards/cicd.html#standard-format","title":"Standard Format","text":"<p><code>v[VERSION].b[SERIAL]-[GIT_SHA]</code></p> <ul> <li>Example: <code>v0.1.b42-a1b2c3d</code></li> <li>Traceability: This provides a classic \"Build 1, Build 2, Build 3\" experience while still being linked to the specific code SHA.</li> <li>Immutability: Once a Build ID is assigned to an image, that number is \"burned\" and must not be reused for different code.</li> </ul>"},{"location":"standards/cicd.html#4-remote-integration","title":"4. Remote Integration","text":"<p>A remote CI tool (if used later) should be a \"dumb\" runner that simply executes the repo's <code>build.sh</code>. <pre><code>./build.sh\n</code></pre></p>"},{"location":"standards/cicd.html#5-blueprint","title":"5. Blueprint","text":"<p>See <code>blueprints/Makefile</code> and <code>blueprints/build.sh</code> for the standard implementations.</p>"},{"location":"standards/coding-guidelines.html","title":"Coding Guidelines","text":""},{"location":"standards/coding-guidelines.html#general-principles","title":"General Principles","text":"<ol> <li>Readability over Cleverness: Code is read more often than it is written.</li> <li>Consistency: Follow the established idioms of the codebase.</li> <li>Standardized Structure: Follow the Repository Structure for all projects.</li> <li>Comments: Comment \"why\", not \"what\". The code explains \"what\".</li> <li>Data-Driven Defaults: Avoid \"Magic String\" defaults for dynamic entities (slugs, IDs). Fetch available values from the API and default to the first valid item if no specific state is provided.</li> </ol>"},{"location":"standards/coding-guidelines.html#language-specific-standards","title":"Language Specific Standards","text":""},{"location":"standards/coding-guidelines.html#javascript-typescript-frontend-mobile","title":"JavaScript / TypeScript (Frontend &amp; Mobile)","text":"<ul> <li>Style Guide: Airbnb or Google Style Guide (enforced via ESLint).</li> <li>Formatting: Prettier.</li> <li>Naming:<ul> <li>Variables/Functions: <code>camelCase</code></li> <li>Classes/Components: <code>PascalCase</code></li> <li>Constants: <code>UPPER_SNAKE_CASE</code></li> </ul> </li> </ul>"},{"location":"standards/coding-guidelines.html#python-backend","title":"Python (Backend)","text":"<ul> <li>Framework: FastAPI is the default for APIs.</li> <li>Style Guide: Follow PEP 8.</li> <li>Type Hints: Mandatory. Do not write functions without type hints.</li> <li>Tooling: Use <code>uv</code> for package management. Use <code>ruff</code> for linting/formatting (it replaces Black/Isort/Flake8).</li> <li>Testing: <code>pytest</code>.</li> </ul>"},{"location":"standards/coding-guidelines.html#html-css-web","title":"HTML / CSS (Web)","text":"<ul> <li>Framework: Tailwind CSS. Do not use Bootstrap or vanilla CSS files unless necessary.</li> <li>Component Library: shadcn/ui.<ul> <li>Do not build complex interactive components (modals, dropdowns) from scratch; use the shadcn (Radix) primitives.</li> <li>Customize the components in <code>components/ui/</code> rather than overriding styles locally where used.</li> </ul> </li> <li>Structure: Component-based. Don't repeat lists of classes; wrap them in a component (e.g., <code>&lt;Button&gt;</code>).</li> <li>Semantic HTML: Tailwind doesn't replace semantics. Use <code>&lt;button&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;h1&gt;</code> appropriately.</li> <li>Ordering: Use a consistent class ordering (e.g., <code>prettier-plugin-tailwindcss</code>) to reduce merge conflicts.</li> </ul>"},{"location":"standards/coding-guidelines.html#mobile-react-native","title":"Mobile (React Native)","text":"<ul> <li>Framework: Expo.</li> <li>Styling: NativeWind. Use Tailwind classes (<code>className=\"flex-1 bg-white\"</code>) exactly as you do on the Web.</li> <li>Navigation: Expo Router. Use file-based routing (<code>app/index.tsx</code>).<ul> <li>Avoid hardcoding platform checks (<code>Platform.OS === 'ios'</code>).</li> <li>Use <code>.native.tsx</code> or <code>.web.tsx</code> extensions if a component must diverge significantly.</li> </ul> </li> </ul>"},{"location":"standards/coding-guidelines.html#database-evolution-migrations","title":"Database Evolution (Migrations)","text":"<ul> <li>Tool: Alembic (Python).</li> <li>Workflow:<ul> <li>Migrations are code. They must be reviewed.</li> <li>Forward Only: Never modify an existing migration file after it has been merged. Create a new one.</li> <li>Non-Destructive: Avoid <code>DROP COLUMN</code> in the same deployment as code usage changes. Usage: \"Expand and Contract\" pattern.</li> </ul> </li> </ul>"},{"location":"standards/coding-guidelines.html#ux-accessibility-a11y","title":"UX &amp; Accessibility (A11y)","text":"<ul> <li>Standard: WCAG 2.1 AA.</li> <li>Requirements:<ul> <li>All interactive elements must have <code>aria-label</code> or accessible text.</li> <li>Color contrast must pass the 4.5:1 ratio.</li> <li>Keyboard navigation must work (focus states).</li> <li>Tools: Use <code>axe-core</code> in E2E tests to auto-detect violations.</li> </ul> </li> </ul>"},{"location":"standards/coding-guidelines.html#tooling","title":"Tooling","text":"<p>All projects must include configuration files (<code>.prettierrc</code>, <code>.eslintrc</code>, <code>pyproject.toml</code>) to enforce these rules automatically in the IDE and CI pipelines.</p>"},{"location":"standards/coding-guidelines.html#error-handling","title":"Error Handling","text":""},{"location":"standards/coding-guidelines.html#python-fastapi","title":"Python (FastAPI)","text":"<ul> <li>Exceptions: Use Python exceptions for control flow.</li> <li>Catching: Catch exceptions at the API layer (<code>exception_handlers.py</code>) and convert them to standard HTTP responses.<ul> <li>Chaining: Always use <code>raise ... from err</code> when re-raising or transforming exceptions to preserve the stack trace. <pre><code>try:\n    data = await service.get_data()\nexcept ValueError as err:\n    raise HTTPException(status_code=400, detail=\"Invalid data\") from err\n</code></pre></li> <li>Do not crash the server on expected errors (e.g., UserNotFound).</li> <li>Do crash (or log error) on unexpected system states (e.g., DB connection lost) so the supervisor can restart the process.</li> </ul> </li> </ul>"},{"location":"standards/coding-guidelines.html#typescript-react","title":"TypeScript / React","text":"<ul> <li>Reactivity: When relying on <code>localStorage</code> for cross-tab or persistent state (e.g., <code>accessToken</code>), use a <code>storage</code> event listener to ensure components remain reactive.</li> <li>Initialization: Initialize error states directly from URL parameters (if applicable) using lazy initializers to avoid redundant renders or race conditions in <code>useEffect</code>.</li> <li>Validation: Use <code>Zod</code> to validate inputs at the boundary.</li> <li>Try/Catch: Use <code>try/catch</code> blocks around async calls.</li> </ul>"},{"location":"standards/coding-guidelines.html#logging","title":"Logging","text":"<p>We use Structured Logging (JSON).</p>"},{"location":"standards/coding-guidelines.html#rules","title":"Rules","text":"<ol> <li>No Print Statements: Never use <code>print()</code> or <code>console.log()</code> in production code. Use the logger.</li> <li>Context: Include context in log messages (e.g., <code>logger.info(\"User logged in\", extra={\"user_id\": 123})</code>).</li> <li>Levels:<ul> <li><code>DEBUG</code>: detailed info for local dev.</li> <li><code>INFO</code>: high-level events (Startup, Request processed).</li> <li><code>ERROR</code>: unexpected exceptions.</li> </ul> </li> </ol>"},{"location":"standards/coding-guidelines.html#software-design-philosophy","title":"Software Design Philosophy","text":"<p>We adopt specific principles to ensure code quality and maintainability (our \"12-Factor for Code\").</p>"},{"location":"standards/coding-guidelines.html#1-solid-principles","title":"1. SOLID Principles","text":"<p>We prioritize these two above all: *   Single Responsibility Principle (SRP): A class/function should have one job.     *   Bad: A generic <code>UserManager</code> that handles DB queries, email sending, and password hashing.     *   Good: <code>UserRepository</code> (DB), <code>EmailService</code> (Email), <code>PasswordHasher</code> (Crypto). *   Dependency Inversion (DIP): Depend on abstractions, not details.     *   Inject dependencies (like <code>db_session</code> or <code>email_client</code>) rather than importing specific implementations globally.</p>"},{"location":"standards/coding-guidelines.html#2-clean-architecture-lite","title":"2. Clean Architecture (Lite)","text":"<p>We enforce a strict dependency flow: *   Controllers (API): Can import Services. Cannot import DB Models directly. *   Services (Business Logic): Can import Repositories. Cannot import HTTP/API code. *   Repositories (Data Access): Can import DB Models. *   Entities/Models: Pure data. Depend on nothing.</p> <p>Rule: Dependencies point inwards. The core business logic should not break if we swap FastAPI for Flask or Postgres for Mongo.</p>"},{"location":"standards/git-workflow.html","title":"Git Workflow","text":""},{"location":"standards/git-workflow.html#branching-strategy","title":"Branching Strategy","text":"<p>We use Main-based Development. 1.  Main Branch: <code>main</code>. Always deployable. 2.  Feature Branches: Short-lived branches created from <code>main</code>.</p>"},{"location":"standards/git-workflow.html#naming-convention","title":"Naming Convention","text":"<p>format: <code>type/description-slug</code> *   <code>feat/user-login</code> *   <code>fix/billing-calculation</code> *   <code>chore/update-deps</code></p>"},{"location":"standards/git-workflow.html#commit-messages","title":"Commit Messages","text":"<p>We follow Conventional Commits. Format: <code>type(scope): description</code></p> <ul> <li><code>feat: add login page</code></li> <li><code>fix(api): handle null user</code></li> <li><code>docs: update architecture diagram</code></li> </ul>"},{"location":"standards/git-workflow.html#pull-requests","title":"Pull Requests","text":"<ul> <li>Small: Aim for PRs &lt; 400 lines of code.</li> <li>Squash &amp; Merge: All PRs are squashed into a single commit on <code>main</code> to keep history linear and clean.</li> </ul>"},{"location":"standards/monitoring.html","title":"Monitoring &amp; Health Standard","text":"<p>To ensure an application is not just \"running\" but \"functioning\", we implement Deep Health Checks and standardized Functioning Signals.</p>"},{"location":"standards/monitoring.html#1-health-endpoints-the-probes","title":"1. Health Endpoints (The Probes)","text":"<p>Applications must expose the following HTTP endpoints. This standard is derived from the Kubernetes (K8s) Probe Architecture, but applies to any orchestrator (AWS Target Groups, GCP Health Checks).</p>"},{"location":"standards/monitoring.html#healthlive-liveness","title":"<code>/health/live</code> (Liveness)","text":"<ul> <li>Question: \"Is the process running?\"</li> <li>Check: Simple 200 OK. No logic.</li> <li>Failure: The process is deadlocked or crash-looping. Action: Restart Container.</li> </ul>"},{"location":"standards/monitoring.html#healthready-readiness","title":"<code>/health/ready</code> (Readiness)","text":"<ul> <li>Question: \"Are you ready to do work?\"</li> <li>Check: Deep check of critical dependencies.<ul> <li>Can I query the Primary Database?</li> <li>Can I reach Redis?</li> <li>(Optional) Are critical downstream services reachable?</li> </ul> </li> <li>Failure: Dependency is down. Action: Stop sending traffic (remove from Load Balancer). Do NOT restart (restarting won't fix the database).</li> <li>UX: This is the answer to \"Is the app functioning?\".</li> </ul>"},{"location":"standards/monitoring.html#healthstartup-startup","title":"<code>/health/startup</code> (Startup)","text":"<ul> <li>Question: \"Has initialization finished?\"</li> <li>Check: Migrations run, caches warmed, models loaded.</li> </ul>"},{"location":"standards/monitoring.html#2-the-red-method-metrics","title":"2. The RED Method (Metrics)","text":"<p>To know how well it is functioning, every service must emit these three metrics (automatically via middleware): 1.  Rate: Request per second. 2.  Errors: % of 5xx responses. (This is your primary \"Is it broken?\" signal). 3.  Duration: P95/P99 Latency.</p>"},{"location":"standards/monitoring.html#3-semantic-monitoring-synthetic-tests","title":"3. Semantic Monitoring (Synthetic Tests)","text":"<p>For critical flows (e.g., \"User can checkout\"), we do not rely solely on passive monitoring. *   Definition: A \"Synthetic Canter\" runs a real script against the production environment every X minutes. *   Standard: Use the same E2E tests (Playwright) defined in Testing Traceability. *   Alert: If the \"Login\" synthetic fails, the app is down, even if <code>/health/ready</code> says the DB is up.</p>"},{"location":"standards/monitoring.html#implementation-example-fastapi","title":"Implementation Example (FastAPI)","text":"<pre><code>from fastapi import FastAPI, Response, status\n\napp = FastAPI()\n\n@app.get(\"/health/live\")\ndef live():\n    return {\"status\": \"ok\"}\n\n@app.get(\"/health/ready\")\ndef ready(db = Depends(get_db)):\n    try:\n        # SELECT 1\n        db.execute(\"SELECT 1\")\n    except Exception:\n        return Response(status_code=status.HTTP_503_SERVICE_UNAVAILABLE)\n    return {\"status\": \"ready\"}\n</code></pre>"},{"location":"standards/repository-structure.html","title":"Repository Structure Standard (v0.1)","text":"<p>This document defines the standard directory layout for all products in the suite. Consistency in structure allows for shared tooling, easier onboarding, and predictable AI-agent interaction.</p>"},{"location":"standards/repository-structure.html#1-high-level-layout","title":"1. High-Level Layout","text":"<p>Every repository follows this top-level structure:</p> <pre><code>repo-root/\n\u251c\u2500\u2500 blueprints/        # reusable templates and configs\n\u251c\u2500\u2500 docs/              # In-depth standards, decisions, and guides\n\u2502   \u251c\u2500\u2500 decisions/     # ADRs\n\u2502   \u2514\u2500\u2500 standards/     # Detailed technical standards\n\u251c\u2500\u2500 planning/          # Epics and stories\n\u251c\u2500\u2500 scripts/           # Automation scripts (docs.py, etc.)\n\u251c\u2500\u2500 src/               # The application source code\n\u2502   \u251c\u2500\u2500 backend/       # API and business logic\n\u2502   \u2514\u2500\u2500 frontend/      # Web/Mobile UI code\n\u251c\u2500\u2500 tests/             # Cross-functional or E2E tests\n\u251c\u2500\u2500 VERSION            # Semantic version of the project\n\u251c\u2500\u2500 build.sh           # Main build/check entry point\n\u2514\u2500\u2500 Makefile           # Standard automation interface\n</code></pre>"},{"location":"standards/repository-structure.html#2-frontend-structure-srcfrontend","title":"2. Frontend Structure (<code>src/frontend/</code>)","text":"<p>We follow a React/Vite/Expo-compatible structure:</p> <ul> <li><code>public/</code>: Unprocessed static assets (favicon, manifest, robots.txt).</li> <li><code>src/</code>: The source code.<ul> <li><code>assets/</code>: Images, fonts, and styles that pass through the build pipeline.</li> <li><code>components/</code>: Reusable UI components (shadcn/ui).</li> <li><code>hooks/</code>: Shared React hooks.</li> <li><code>lib/</code>: Third-party library initializations (API clients).</li> <li><code>types/</code>: TypeScript definitions.</li> </ul> </li> </ul>"},{"location":"standards/repository-structure.html#3-backend-structure-srcbackend","title":"3. Backend Structure (<code>src/backend/</code>)","text":"<p>We follow a \"Clean Architecture Lite\" structure:</p> <ul> <li><code>api/</code>: FastAPI routes and dependency injection.</li> <li><code>core/</code>: Pure business logic (Services/Entities).<ul> <li><code>config/</code>: Environment configuration.</li> </ul> </li> <li><code>db/</code>: Database models and migration scripts (Alembic).</li> <li><code>schemas/</code>: Pydantic models for request/response validation.</li> </ul>"},{"location":"standards/repository-structure.html#4-built-vs-source","title":"4. Built vs Source","text":"<ul> <li>Source: Everything inside <code>src/</code>, <code>docs/</code>, <code>planning/</code>, etc.</li> <li>Built: Directories generated by tools must be excluded from version control and isolated.<ul> <li><code>/dist/</code>: Production builds.</li> <li><code>/build/</code>: Temporary build artifacts.</li> <li><code>/.tmp/</code> or <code>/temp/</code>: Ephemeral data.</li> <li><code>/node_modules/</code>, <code>/.venv/</code>: Dependency directories.</li> </ul> </li> </ul>"},{"location":"standards/security.html","title":"Security Standards","text":"<p>This document defines the Product Security Baseline that all applications must meet before going to production.</p>"},{"location":"standards/security.html#1-authentication-authorization","title":"1. Authentication &amp; Authorization","text":"<ul> <li>Protocol: OAuth 2.0 / OIDC is the standard. Avoid custom auth schemes.</li> <li>Tokens: Use Short-lived JWTs (Access Tokens) + HttpOnly Cookies (Refresh Tokens) for web clients.<ul> <li>Never store sensitive tokens in LocalStorage (vulnerable to XSS).</li> </ul> </li> <li>RBAC: Implement Role-Based Access Control at the API Gateway or Middleware level.<ul> <li>API endpoints must explicitly declare required roles (e.g., <code>@requires_role(\"admin\")</code>).</li> </ul> </li> </ul>"},{"location":"standards/security.html#2-input-validation-zero-trust","title":"2. Input Validation (Zero Trust)","text":"<ul> <li>Sanitization: Never trust user input. Use libraries (Pydantic, Zod) to strict-type and validate all incoming data.</li> <li>SQL Injection: Never write raw SQL strings with concatenation. Always use the ORM or parameterized queries.</li> <li>XSS: Use modern frontend frameworks (React) which escape by default. Audit <code>dangerouslySetInnerHTML</code> usage.</li> </ul>"},{"location":"standards/security.html#3-data-protection","title":"3. Data Protection","text":"<ul> <li>Encryption at Rest: PII (Personally Identifiable Information) must be encrypted in the DB.</li> <li>Encryption in Transit: TLS 1.2+ everywhere. FORCE_SSL must be enabled.</li> <li>Secrets:<ul> <li>Never commit secrets to Git.</li> <li>Use <code>.env</code> files for local dev (gitignored).</li> <li>Use Secret Managers (AWS Secrets Manager, Doppler, K8s Secrets) in production.</li> </ul> </li> </ul>"},{"location":"standards/security.html#4-http-security-headers","title":"4. HTTP Security Headers","text":"<p>All web responses must set standard security headers: *   <code>Content-Security-Policy</code> (CSP): Restrict script sources. *   <code>X-Content-Type-Options: nosniff</code> *   <code>X-Frame-Options: DENY</code> *   <code>Strict-Transport-Security</code> (HSTS)</p>"},{"location":"standards/security.html#5-dependency-management","title":"5. Dependency Management","text":"<ul> <li>SCA: Run <code>npm audit</code> and <code>pip-audit</code> in CI/CD.</li> <li>Updates: Keep dependencies patched.</li> </ul>"},{"location":"standards/security.html#6-error-handling","title":"6. Error Handling","text":"<ul> <li>Information Leakage: API errors must NEVER return stack traces to the client in production.</li> <li>Use standard error codes (RFC 7807) to help the frontend handle errors gracefully without exposing internals.</li> </ul>"},{"location":"standards/testing_traceability.html","title":"Requirement-Test Traceability Standard","text":"<p>To ensure every requirement is tested and every test represents a valid requirement (\"No Orphan Code\"), we use a Traceability Standard driven by IDs and Gherkin behavior specs.</p>"},{"location":"standards/testing_traceability.html#1-requirement-ids","title":"1. Requirement IDs","text":"<p>Every functional requirement in a PRD must have a stable, unique ID. *   Format: <code>REQ-[COMPONENT]-[NUMBER]</code> *   Example: <code>REQ-AUTH-001</code> (User Login), <code>REQ-CART-005</code> (Add item)</p>"},{"location":"standards/testing_traceability.html#2-behavioral-specs-gherkin","title":"2. Behavioral Specs (Gherkin)","text":"<p>For complex user flows (E2E candidates), requirements must be defined using Gherkin syntax (Given/When/Then). This serves as the \"Source of Truth\" for generative testing.</p> <p>In the PRD: <pre><code>Feature: User Login\n  @REQ-AUTH-001\n  Scenario: Successful login with valid credentials\n    Given the user is on the login page\n    When they enter valid username \"alice\" and password \"secure123\"\n    Then they are redirected to the dashboard\n</code></pre></p>"},{"location":"standards/testing_traceability.html#3-linking-in-code","title":"3. Linking in Code","text":"<p>Tests must reference the ID they verify. This allows us to grep for coverage.</p>"},{"location":"standards/testing_traceability.html#backend-pytest","title":"Backend (Pytest)","text":"<p>Use a custom marker or docstring reference. <pre><code>import pytest\n\n@pytest.mark.req(\"REQ-AUTH-001\")\ndef test_login_success():\n    \"\"\"Verifies REQ-AUTH-001: Successful login\"\"\"\n    ...\n</code></pre></p>"},{"location":"standards/testing_traceability.html#frontende2e-playwright","title":"Frontend/E2E (Playwright)","text":"<p>Use the annotation API. <pre><code>test('user can log in', async ({ page }) =&gt; {\n  test.info().annotations.push({ type: 'req', description: 'REQ-AUTH-001' });\n  // ... test code\n});\n</code></pre></p>"},{"location":"standards/testing_traceability.html#4-generating-tests-from-requirements","title":"4. Generating Tests from Requirements","text":"<p>Because we use Gherkin in the PRD, we can define the standard for Automated Test Generation:</p> <ol> <li>Input: PRD with valid Gherkin scenarios.</li> <li>Process: AI Agent or Code Gen tool reads the Gherkin.</li> <li>Output: Playwright test skeleton with <code>test.step</code> mapping one-to-one with Gherkin lines. See <code>blueprints/prd.md</code> for the standard template structure.</li> </ol> <p>Example Generated Code: <pre><code>test('Successful login with valid credentials', async ({ page }) =&gt; {\n  test.info().annotations.push({ type: 'req', description: 'REQ-AUTH-001' });\n\n  await test.step('Given the user is on the login page', async () =&gt; {\n    await page.goto('/login');\n  });\n\n  await test.step('When they enter valid username...', async () =&gt; {\n    // ...\n  });\n});\n</code></pre></p>"},{"location":"standards/testing_traceability.html#5-automated-environment-management","title":"5. Automated Environment Management","text":"<p>For E2E tests, the environment should ideally be started automatically. We use Playwright's <code>webServer</code> feature in <code>playwright.config.ts</code>.</p> <p>Standard Config: <pre><code>export default defineConfig({\n  // ...\n  webServer: {\n    command: 'make dev', // Starts backend &amp; frontend\n    url: 'http://localhost:5173',\n    reuseExistingServer: !process.env.CI,\n  },\n});\n</code></pre> This ensures a \"single command\" testing experience (<code>make test-e2e</code>) even on fresh clones.</p>"}]}